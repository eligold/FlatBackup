#!/usr/bin/env /root/carcam/bin/python
import logging, ffmpeg
from logging.handlers import RotatingFileHandler
from multiprocessing import Process, Pipe
from queue import SimpleQueue, Empty
from linuxpy.video.device import Device, VideoCapture
from gpiozero import CPUTemperature
from evdev import InputDevice
from collections import deque
from threading import Thread
from time import time

from Constants import *
from ELM327 import ELM327
# communications between threads:
touch_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)
# communications between processes:
backup_pipe1, backup_pipe2 = Pipe()
sidebar_pipe1, sidebar_pipe2 = Pipe()
dash_pipe1, dash_pipe2 = Pipe()
# global flags
show_graph = False
exit_flag = False
# load up sidebar prototypes for normal and high temp
sidebar_hot = cv.cvtColor(cv.imread("/root/turboSB_hot.png"),BGR565)[-160:,:120]
sidebar_fine = cv.cvtColor(cv.imread("/root/turboSB.png"),BGR565)[-160:,:120]
def _sidebar_hot(): _change_sidebar(sidebar_hot)
def _change_sidebar(img=sidebar_fine):
    global sidebar_base
    sidebar_base=img.copy()
_change_sidebar()
# CPU temp tracked with gpio library reading internal ADC
intemp = CPUTemperature(threshold=HIGH_TEMP,event_delay=1.9)
intemp.when_activated = _sidebar_hot
intemp.when_deactivated = _change_sidebar
# Display frame buffer memory mapped with numpy
frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:160,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)
# convenience method to print message on screen
def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))
# load private bluetooth MAC address for my phone
with open("/root/.btmac","r") as file: mac = file.readline()
# use with subprocess to check if wifi is connected
wifi_command= 'cat /sys/class/net/wlan0/operstate'

def show(back_pipe=backup_pipe1, dash_pipe=dash_pipe1, side_pipe=sidebar_pipe1):
    show_graph, view_flag, exit_flag = False, False, False
    back_proc, dash_proc, dash_image = None, None, None
    if bash(wifi_command).stdout == b'up\n': pass # return # is wifi connected?
    else: 
        bash('ip link set wlan0 down') # else turn off radio to save power
        Popen(f"sleep 5 && bluetoothctl connect {mac}",shell=True)
    _show_message("Initializing.", (500,250))
    back_proc = Process(target=get_image, name="read")
    back_proc.start()
    _show_message("Initializing..", (500,250))
    dash_proc = Process(target=get_dash_image, name="dash")
    dash_proc.start()
    _show_message("Initializing...", (500,250))
    while not exit_flag:
        if side_pipe.poll(): frame_buffer[:SIDEBAR_HEIGHT,-SIDEBAR_WIDTH:] = side_pipe.recv()
        if dash_pipe.poll(): dash_image = dash_pipe.recv()
        if back_pipe.poll(FRAME_DELAY):
            data_msg = back_pipe.recv()
            if isinstance(data_msg,str):
                if "VIEW" == data_msg: 
                    view_flag = not view_flag
                    dash_pipe.send("START_VIEW" if view_flag else "STOP_VIEW")
                elif "GRAPH" == data_msg: show_graph = not show_graph
                elif "STOP" == data_msg: exit_flag = True
                else: logger.warning(f"bad message from data: {data_msg}")
            elif not exit_flag:
                img_data = data_msg[0] if show_graph else data_msg
                back_image = cv.cvtColor(img_data,YUV422)
                if view_flag: image = output_alt(adv(back_image), dash_image)
                else: image = build_output_image(adv(back_image))
                if show_graph: image = addOverlay(image)
                frame_buffer[:,:-SIDEBAR_WIDTH] = cv.cvtColor(image, BGR565)
                if show_graph: build_graph(data_msg[1], frame_buffer) # boost over time
                frame_buffer.flush() # round and round we go to keep OS happy
    for pipe in dash_pipe, back_pipe:
        pipe.send("STOP")
        while not pipe.poll(0.19): pass
        data_msg = pipe.recv()
        while not (isinstance(data_msg,str) and "STOP" == data_msg): data_msg = pipe.recv()
    if dash_proc is not None: dash_proc.join()
    if back_proc is not None: back_proc.kill()
        

def touch_thread(queue=touch_queue):
    global exit_flag
    touch_input, x = None, None
    touch_time, counter = time() + 0.19, 0
    while not exit_flag:
        if time() > touch_time:
            try:
                if touch_input is None: touch_input = InputDevice(touchDevPath)
                for event in touch_input.read():
                    if event.type == 3: touch_msg = _touch_logic(event,x)
                    if touch_msg is not None:
                        queue.put(touch_msg)
                        touch_msg = None
            except BlockingIOError: pass # no new input
            except (OSError, FileNotFoundError): # janky mcu is ailing
                if counter > 3:
                    if touch_input is not None:
                        touch_input.close()
                        touch_input = None
                    touch_time = time() + 0.38
                    counter = 0
                else: counter += 1
    if touch_input is not None: touch_input.close()

def _touch_logic(event,x):
    global show_graph
    if event.code == 0: # Code 0 gives the X coordinate
        if event.value > FINAL_IMAGE_WIDTH: x = event.value
        else: return "VIEW" # tap image to change view
    else: # Sidebar actions defined here
        if x is not None and event.code == 1:
            if event.value > SCREEN_HEIGHT/2: # bottom half exits
                logger.info(f'touch input (X ⇁,Y ⇃) -> {x},{event.value}')
                return "STOP"
            else:
                show_graph = not show_graph
                return "GRAPH" # top half displays PSI graph
        x = None # TODO VALIDATE THIS CHANGES X IN THREAD!!!
    return None

def make_sidebar(pipe=sidebar_pipe2,color=COLOR_NORMAL):
    global exit_flag
    global psi_list
    car_connection = None
    try:
        car_connection = ELM327("/dev/ttyS0") # hardware UART
        while not exit_flag:
            sidebar = sidebar_base.copy()
            try: psi = car_connection.psi()
            except Exception as e: logger.exception(e) # fancy math converts value to pixel height
            psi_list.append(max(FDIM[1] - 2 * PPPSI - 15 - int(psi*PPPSI),1)) #  with 30px per PSI
            sidebar = putText(sidebar,f"{psi:.1f}",(4,57),color=color,fontScale=1.19,thickness=3)
            sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (42,95), color=COLOR_BAD)
            pipe.send(sidebar) # send it along to the display thread
            if exit_flag: break
    except Exception as e: logger.exception(e)
    finally:
        if car_connection is not None: car_connection.close()

def get_image(pipe=backup_pipe2):
    global exit_flag
    global show_graph
    while not exit_flag:
        try:
            with Device.from_id(extract_index(backupCamPath)) as cam:
                Thread(target=make_sidebar, name="data", daemon=True).start()
                Thread(target=touch_thread, name="touch", daemon=True).start()
                for frame in cam:
                    if not pipe.poll():
                        img = frame.array.reshape(frame.height,frame.width,2)
                        pipe.send((img, psi_list.copy()) if show_graph else img)
                        try: pipe.send(touch_queue.get(block=False))
                        except Empty: pass
                    else:
                        pipe.recv()
                        exit_flag = True
                    if exit_flag: break   
        except Exception as e: logger.exception(e)
    pipe.send("STOP")

def get_dash_image(width=DASHCAM_IMAGE_WIDTH, height=DASHCAM_IMAGE_HEIGHT, dash_pipe=dash_pipe2):
    view_flag, exit_flag = False, False
    lines = []
    process = (ffmpeg.input('pipe:', format='mjpeg', framerate=15)
        .output(get_video_path(), vcodec='copy', framerate=15, format='matroska')
        .overwrite_output().run_async(pipe_stdin=True,pipe_stderr=True))
    stderr_iterator = iter(process.stderr.readline, b'')
    while not exit_flag:
        try:
            with Device.from_id(extract_index(dashCamPath)) as cam:
                video_capture = VideoCapture(cam)
                video_capture.set_format(width,height,"MJPG")
                with video_capture as stream:
                    for frame in stream:
                        if view_flag: dash_pipe.send(cv.imdecode(frame.array, COLOR))
                        process.stdin.write(frame.data)
                        if dash_pipe.poll():
                            msg = dash_pipe.recv()
                            if "START_VIEW" == msg: view_flag = True
                            elif "STOP_VIEW" == msg: view_flag = False
                            elif "STOP" == msg: 
                                process.stdin.flush()
                                process.stdin.close()
                                try:
                                    for line in stderr_iterator:
                                        line = line.decode().strip()
                                        if line.startswith('frame='): line = line.split('\r')[-1]
                                        lines.append(line)
                                    process.stderr.close()
                                except Exception as e: logger.exception(e)
                                exit_flag = True
                            else: logger.error(f"bad message from main process: {msg}")
                        if exit_flag: break
        except (EOFError, BrokenPipeError, OSError): break
        except AssertionError: logger.error("can't find usb") # reset_usb()
        except Exception as e: logger.exception(e)
        if exit_flag: break
    try:
        process.terminate()
        process.kill()
    except Exception as e: logger.exception(e)
    if len(lines) > 0: logger.info(lines)
    dash_pipe.send("STOP")

if __name__ == "__main__":
    fmtString = '%(asctime)s [%(levelname)-4s] %(threadName)s: %(message)s'
    logFilePath = "/media/usb/runtime-carCam.log"
    handler = RotatingFileHandler(logFilePath, maxBytes=209715200, backupCount=2)
    level = logging.INFO # DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler)
    bash('echo none > /sys/class/leds/PWR/trigger; \
         echo 0 > /sys/class/leds/PWR/brightness; \
         echo 38 > /sys/class/leds/ACT/brightness')
    try: show() # turn off red LED  /\  /\
    except Exception as ex: logger.exception(ex)
    finally:
        if not b'up\n' == bash(wifi_command).stdout: shell("shutdown -h now")
