#!/usr/bin/env python3
import logging, traceback, ffmpeg
from multiprocessing import Process, Pipe
from queue import SimpleQueue
from v4l2py import Device, VideoCapture
from gpiozero import CPUTemperature
from evdev import InputDevice
from collections import deque
from threading import Thread
from time import time

from Constants import *
from ELM327 import ELM327

# communications between processes and threads:
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)
touch_queue = SimpleQueue()
backup_queue = SimpleQueue()
image_pipe1, image_pipe2 = Pipe()
data_pipe1, data_pipe2 = Pipe()

show_graph = False
exit_flag = False
touch_exit = False
view_flag = False
HIGH_TEMP = 55.0
FRAME_DELAY = 0.119

sidebar_hot = cv.cvtColor(cv.imread("/root/turboSB_hot.png"),BGR565)[-160:,:120]
sidebar_cool = cv.cvtColor(cv.imread("/root/turboSB.png"),BGR565)[-160:,:120]
def _sidebar_hot(): _change_sidebar(sidebar_hot)
def _change_sidebar(img=sidebar_cool):
    global sidebar_base
    sidebar_base=img.copy()
_change_sidebar()

intemp = CPUTemperature(threshold=HIGH_TEMP,event_delay=1.9)
intemp.when_activated = _sidebar_hot
intemp.when_deactivated = _change_sidebar

# Display frame buffer memory mapped with numpy
frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:160,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)

def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))

# load private bluetooth MAC address for my phone
with open("/root/.btmac","r") as file: mac = file.readline()
def _wifi_state(): return bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n'

def begin(queue=backup_queue, dash_pipe=image_pipe1, data_pipe=data_pipe2):
    dash_process, back_image, dash_image = None, None, None
    global view_flag
    global exit_flag
    global show_graph
    try: # is the wifi connected?
        if _wifi_state(): pass # raise KeyboardInterrupt("wifi connected")
        else: 
            bash('ip link set wlan0 down') # else turn off radio to save power
            Popen(f"sleep 5 && bluetoothctl connect {mac}", shell=True)
        Thread(target=get_image,name="read",daemon=True).start()
        dash_process = Process(target=dashcam_process, name="dash")
        dash_process.start()
        _show_message("Initializing...", (500,250))
        while not exit_flag:
            try:
                if exit_flag: break
                if data_pipe.poll():
                    msg = data_pipe.recv()
                    if isinstance(msg, str):
                        if "VIEW" == msg: view_flag = not view_flag
                        elif "GRAPH" == msg: show_graph = not show_graph
                        elif "STOP" == msg: exit_flag = True
                        else: logger.error(f"bad message from main pipe: {msg}")
                    else: psi_list.append(pixel_psi(data_pipe.recv()))
                try: back_image = queue.get(FRAME_DELAY)
                except: continue
                if view_flag:
                    if dash_pipe.poll(): dash_image = dash_pipe.recv()
                    if dash_image is not None: image = output_alt(back_image,dash_image)
                if not view_flag or dash_image is None: image = build_output_image(back_image)
                if show_graph: image = addOverlay(image)
                frame_buffer[:,:-SIDEBAR_WIDTH] = cv.cvtColor(image, BGR565)
                if show_graph: build_graph(psi_list.copy(), frame_buffer) # boost over time
                frame_buffer.flush() # round and round we go to keep the OS happy
            except (EOFError, BrokenPipeError, OSError): break
            except Exception as e: logger.exception(e)
            if exit_flag: break # PROBABLY EXTRANEOUS
    except KeyboardInterrupt: exit_flag = True
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)
    finally: leave(dash_process, dash_pipe)

def leave(dash_process, dash_pipe, msg=None):
    global exit_flag
    dash_pipe.send("STOP")
    if not exit_flag: exit_flag = True
    start_time = time() ## DEBUG
    while not dash_pipe.poll():
        if dash_pipe.poll(): msg = dash_pipe.recv()
        if isinstance(msg, str) and "STOP" == msg: break
    dash_process.join()
    logger.info(f"{time() - start_time}s to join procs")
   # if not _wifi_state(): Popen("shutdown -h now",shell=True) # bash('ip link set wlan0 up')
    bash(f"bluetoothctl disconnect {mac}")

def get_image(queue=backup_queue):
    width, height = DIM
    read_fail_count = 0
    camera = None
    global exit_flag
    while not exit_flag:
        try:
            camera = get_camera(extract_index(),width,height)
            camera.read()
            while camera.isOpened():
                if exit_flag: break
                success, image = camera.read()
                if success: queue.put(image)
                else: read_fail_count += 1
        except Exception as e: logger.exception(e)
        finally:
            if camera is not None: camera.release()
            print(f'failed reads: {read_fail_count}')
        if exit_flag: break
    print("leaving backup cam read thread")

def touch_thread(pipe=data_pipe1, queue=touch_queue):
    global exit_flag
    global touch_exit
    global show_graph
    global view_flag
    touch_input, x = None, None
    touch_dev_path = "/dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00"
    touch_time = time() + 0.19
    counter = 0
    while not touch_exit: # TODO THIS IS BAD IF NOT SHUTTING DOWN
        if time() > touch_time:
            try:
                if touch_input is None: touch_input = InputDevice(touch_dev_path)
                for event in touch_input.read():
                    if event.type == 3:
                        if event.code == 0:
                            if event.value > FINAL_IMAGE_WIDTH: x = event.value
                            else: 
                                view_flag = not view_flag
                                pipe.send("VIEW")
                        else:
                            if x is not None and event.code == 1:
                                if event.value > SCREEN_HEIGHT/2:
                                    msg = f'touch input (X ⇁,Y ⇃) -> {x},{event.value}'
                                    logger.info(msg)
                                    pipe.send("STOP")
                                    exit_flag = True # queue.put("STOP")
                                else:
                                    show_graph = not show_graph
                                    pipe.send("GRAPH")
                            x = None
                touch_time =  time() + 0.19
            except BlockingIOError: pass # no new input
            except (OSError, FileNotFoundError): # janky mcu is ailing
                if counter > 3:
                    if touch_input is not None:
                        touch_input.close()
                        touch_input = None
                    touch_time = time() + 0.38
                    counter = 0
                else: counter += 1
            except Exception as e: logger.exception(e)

def make_sidebar(pipe=data_pipe1,color=COLOR_NORMAL):
    global psi_list
    global exit_flag
    try:
        car_connection = ELM327("/dev/ttyS0")
        while not exit_flag:
            sidebar = sidebar_base.copy()
            try: psi = car_connection.psi()
            except Exception as e: logger.exception(e)
            sidebar = putText(sidebar,f"{psi:.1f}",(4,57),color=color,fontScale=1.19,thickness=3)
            sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (42,95), color=COLOR_BAD)
            try: pipe.send(psi) # send it along to the display thread
            except (EOFError, BrokenPipeError, OSError): break
            frame_buffer[:SIDEBAR_HEIGHT,-SIDEBAR_WIDTH:] = sidebar # TODO IS THIS PROCESS SAFE?
            if exit_flag: break
    except Exception as e: logger.exception(e)
    finally: car_connection.close()

def dashcam_process(show_pipe=image_pipe2):
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    ffmpeg_process, touch_thread, sidebar_thread = None, None, None
    width, height = DASHCAM_IMAGE_WIDTH, DASHCAM_IMAGE_HEIGHT
    global view_flag
    global exit_flag
    global touch_exit
    try:
        touch_thread = Thread(target=touch_thread, name="touch") # , daemon=True).start()
        sidebar_thread = Thread(target=make_sidebar, name="data")
        for thread in (touch_thread,sidebar_thread): thread.start()
        while not exit_flag:
            ffmpeg_process = (ffmpeg.input('pipe:', format='mjpeg', framerate=15)
                             .output(get_video_path(),vcodec='copy',framerate=15,format='matroska')
                             .overwrite_output().run_async(pipe_stdin=True))
            try:
                with Device.from_id(extract_index(camPath)) as cam:
                    video_capture = VideoCapture(cam)
                    video_capture.set_format(width,height,"MJPG")
                    with video_capture as stream:
                        for frame in stream:
                            ffmpeg_process.stdin.write(frame.data)
                            if show_pipe.poll(): exit_flag = True
                            if view_flag: show_pipe.send(cv.imdecode(frame.array, COLOR))
                            if exit_flag: break
            except (EOFError, BrokenPipeError, OSError): break
            except AssertionError: logger.error("can't find usb") # reset_usb()
            except Exception as e: logger.exception(e)
            finally:
                if ffmpeg_process is not None:
                    ffmpeg_process.stdin.close()
                    ffmpeg_process.wait()
                print("output released")
            if exit_flag: break
    except Exception as e: logger.exception(e)
    finally:
        if sidebar_thread is not None: sidebar_thread.join()
        touch_exit = True
        if touch_thread is not None: touch_thread.join()
        show_pipe.send("STOP")
        if not _wifi_state(): Popen("sleep 1 && shutdown -h now", shell=True)
        print("leaving dash process")

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    level = logging.INFO # DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler) # turn off red LED \/  \/
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    begin()
