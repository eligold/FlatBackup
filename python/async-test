#!/usr/bin/env python3
import asyncio, os
from collections import deque
from time import perf_counter_ns as perf_counter
from evdev import InputDevice, categorize, ecodes
from v4l2py import Device, VideoCapture
from gpiozero import CPUTemperature

from ImageConstants import *
from ELM327 import ELM327

frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(480,1600,2))
try: frame_buffer[160:,-SIDEBAR_WIDTH:] = cv.imread("/root/newSidebar.png")
except: pass

touch_input_device = InputDevice("/dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00")

usb_capture_id_path = "/dev/v4l/by-id/usb-MACROSIL_AV_TO_USB2.0-video-index0"
usb_capture_real_path = os.path.realpath(usb_capture_id_path)
assert usb_capture_id_path != usb_capture_real_path
cameraIndex = int(usb_capture_real_path.split("video")[-1])

car_conn = ELM327()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)

exit_flag = False
show_graph = False
sidebar_lock = False

display_times = []

def sidebar_hot():
    print("temp over 60C") # logger.warning(
    _change_sidebar(COLOR_REC)
def sidebar_cool():
    print("temperature below 60C") # logger.info(
    _change_sidebar()
def _change_sidebar(color=COLOR_NEW): # COLOR_LOW
    global sidebar_base
    global sidebar_lock
    while sidebar_lock: pass
    sidebar_lock = True
    sidebar_base=np.full((SIDEBAR_HEIGHT,SIDEBAR_WIDTH,2),color,np.uint8)
    sidebar_lock = False
_change_sidebar()

intemp = CPUTemperature(threshold=60.0,event_delay=1.9)
intemp.when_activated = sidebar_hot
intemp.when_deactivated = sidebar_cool

async def touch_input():
    global exit_flag, show_graph
    x = None
    last_time = time()
    async for event in touch_input_device.async_read_loop():
        print(categorize(event))
        if time() > last_time + 0.38 and event.type == ecodes.EV_ABS:
            if event.code == 0 and event.value > FINAL_IMAGE_WIDTH:
                x = event.value
            else:
                if x is not None and event.code == 1:
                    if event.value > SCREEN_HEIGHT/2: 
                        exit_flag = True
                        break
                    else: show_graph = not show_graph
                    x = None
                    last_time = time()
        if exit_flag: break

async def get_image(cameraIndex=cameraIndex, width=720, height=576, format_string="YUYV"):
    global start
    with Device.from_id(cameraIndex) as cam:
        c = VideoCapture(cam)
        c.set_format(width,height,format_string)
        with c as stream:
            async for frame in stream:
                if exit_flag: break

                start = perf_counter()

                if format_string == "YUYV":
                    raw = np.frombuffer(frame.data, dtype="uint8", count=width*height*2)
                    yield cv.cvtColor(raw.reshape(height,width,2), cv.COLOR_YUV2BGR_YUYV)
                else:
                    yield cv.imdecode(np.frombuffer(frame.data,dtype="uint8"),cv.IMREAD_ANYCOLOR)

async def process_image():
    async for image in get_image():#height=480,format_string="MJPG"): # local testing only
        if image is not None:
            image = build_output_image(image)
            if exit_flag: break
            yield cv.cvtColor(addOverlay(image) if show_graph else image, BGR565)
        else: print("empty image!")

async def on_screen():
    global frame_buffer
    async for image in process_image():
        try: frame_buffer[:,:1480] = image
        except: traceback.print_exc()
        frame_buffer.flush()
        if exit_flag: break

        display_times.append(perf_counter()-start)

async def get_speed():
    async with car_conn as elm: # while not exit_flag:?
        try: yield elm.speed()
        except: traceback.print_exc()

async def obd_data():
    async with car_conn as elm: # while not exit_flag:?
        try: psi = elm.psi()
        except: traceback.print_exc()
        entry = int(psi*PPPSI)
        psi_list.append(entry)
        yield psi

async def sidebar_builder():
    global frame_buffer
    async for psi in obd_data():
        while sidebar_lock: pass
        sidebar_lock = True
        sidebar = sidebar_base.copy()
        sidebar_lock = False
        sidebar = \
            putText(sidebar, f"{psi:.1f}",(4,57), color=COLOR_NORMAL, fontScale=1.19, thickness=3)
        try: frame_buffer[:160,-SIDEBAR_WIDTH:] = \
            putText(sidebar, "BAR" if psi < 0.0 else "PSI", (60,95), color=COLOR_BAD)
        except: traceback.print_exc()
        if exit_flag: break

async def get_dashcam_image():
    width, height = DASHCAM_IMAGE_WIDTH, DASHCAM_IMAGE_HEIGHT
    usb_capture_id_path = \
        "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    usb_capture_real_path = os.path.realpath(usb_capture_id_path)
    assert usb_capture_id_path != usb_capture_real_path
    dashcam_index = int(usb_capture_real_path.split("video")[-1])

    async for image in get_image(dashcam_index,width,height,"MJPG"):
        speed = await get_speed()
        yield putText(image,f"{speed} mph",(10,1934)) if speed else image

async def run_dashcam():
    local_time = localtime()
    fourcc = cv.VideoWriter_fourcc(*'H264') #*'MJPG')
    width, height = DASHCAM_IMAGE_WIDTH, DASHCAM_IMAGE_HEIGHT
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mkv"
    output = cv.VideoWriter(filepath,fourcc,15,(width, height))
    async for image in get_dashcam_image():
        try: output.write(image)
        except: traceback.print_exc()
        if exit_flag: break
    output.release()

def ms(num):
    return f"{num/1000000.0:.1f}"

async def main():
    await asyncio.gather(run_dashcam(),touch_input(),on_screen(),sidebar_builder()) # ,get_speed())
#try: asyncio.run(on_screen)
try: asyncio.run(main())
except: pass
print(f"time stats:\nmin: {ms(min(display_times))}ms\tmax: {ms(max(display_times))}ms\tmode: {ms(max(display_times,display_times.count))}\nmean: {ms(np.mean(display_times))}ms\tmedian: {ms(np.median(display_times))}ms")
