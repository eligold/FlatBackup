#!/usr/bin/env python3
import traceback, logging
from subprocess import run, Popen, PIPE, TimeoutExpired
from threading  import Thread
from time import localtime, time
from touchEvent import touchEvent
from ELM327 import ELM327
from ImageProc import *

def main():
    global exit_flag
    wifi_flag = False
    bluetooth_process = None
    dashcam_proc = None
    with open("/root/.btmac","r") as file: mac = file.readline()#try:
    try: # is the wifi connected?                                    \\ YOOHOO //
        if bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n': pass
           # raise KeyboardInterrupt("wifi connected") # else turn off radio to save power
        else: wifi_flag = shell('ip link set wlan0 down').wait() == 0
        bluetooth_process = shell(f"bluetoothctl connect {mac}",text=True)
        started_names = []
        for function, name in [
                (touch_input,"taps"),
                (get_image,"read"),
                (on_screen,"show"),
                (sidebar_builder,"obd2")]:
            Thread(target=function,name=name,daemon=True).start()
            started_names.append(name)
        logger.info(f'threads started: {started_names}')
        return_code = bluetooth_process.wait()
## DEBUG ############################################################
        for bt_line in bluetooth_process.stdout.readlines(): logger.info(bt_line.rstrip())
        logger.info("Bluetooth success?" if return_code == 0 else f"BT return code: {return_code}")
## /DEBUG ###########################################################
        while not exit_flag:
            return_code = 0
            dashcam_proc = start_dash_cam()
            while not exit_flag:
                try: return_code = dashcam_proc.wait(1.9)
                except TimeoutExpired: pass
                else:
                    for dash_ln in dashcam_proc.stdout.readlines(): logger.info(dash_ln)
                    if return_code: log_dashcam_errors(dashcam_proc)
                if exit_flag: break
            if exit_flag: break
    except Exception as ex:
        if dashcam_proc: dashcam_proc.terminate()
        traceback.print_exc()
        logger.exception(ex)
    finally:# leave(dashcam_proc,wifi_flag)
## DEBUG ## ↑ delete ################################################
        logger.info(f"display queue: {display_queue.qsize()}")
        for times,label in ((cam_times,"read"),(proc_times,"proc"),(display_times,"disp")):
            if times: logger.info(f"[{label}] time stats:\nmin: {min(times)*1000:.1f}ms\tmax: {max(times)*1000:.1f}ms\t mode:{max(times,key=times.count)*1000:.1f}ms\nmean: {np.mean(times)*1000:.1f}ms\tmedian: {np.median(times)*1000:.1f}ms")
            else: logger.error(f"timer {label} failed to init")
        leave(dashcam_proc,wifi_flag)
## /DEBUG ###########################################################

def leave(dashcam_proc, wifi_flag):
    global exit_flag
    exit_flag = True
    if dashcam_proc: dashcam_proc.kill()
    if wifi_flag: bash('ip link set wlan0 up',check=False)

def log_dashcam_errors(dashcam_proc):
    logger.error(f"dashcam command exit code: {dashcam_proc.returncode}")
    for err_ln in dashcam_proc.stderr.readlines(): 
        logger.error(err_ln)

def sidebar_builder():
    global sidebar_queue
    global frame_buffer
    global exit_flag
    car_conn = None
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing...",(500,250),fontScale=3,thickness=4)
    while not exit_flag:
        try:
            car_conn = ELM327()
            while not exit_flag:
                make_sidebar(car_conn.psi())
        except Exception as e:# logger.exception(e)
## DEBUG #################### ↑ delete ##############################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################
        finally:
            if car_conn: car_conn.close()
        if exit_flag: break

def touch_input():
    global show_graph, exit_flag
    touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'
    touch_process = None
    x = None
    last_time = time()
    while not exit_flag:
        try:
            touch_process = shell(touch_command,text=True)
            while not "interrupt to exit" in touch_process.stdout.readline(): pass
            while not exit_flag:
                active = False # test for only code_id = 5 to detect press and hold
                event = touchEvent(touch_process.stdout.readline())
                if event.time > last_time + 0.19: active = True
                try:
                    while not "-- SYN_REPORT --" in event.code: # check .valid instead
                        event = touchEvent(touch_process.stdout.readline())
                        if active and event.isX:
                            if event.value >= FINAL_IMAGE_WIDTH: x = event.value
                            else:
                                last_time = event.time
                                active = False
                        if active and event.isY:
                            if event.value < SCREEN_HEIGHT/2: show_graph = ~show_graph
                            else: raise KeyboardInterrupt(f'touch input(X →,Y ↓) -> {x},{event.value}')
                        if event.code_id != 5: logger.info(event.pretty())
                    if active: last_time = event.time
                except: print(event.pretty())
                x = None
                if exit_flag: break
        except KeyboardInterrupt as kbi: raise kbi
        except Exception as e:# logger.exception(e)
## DEBUG #################### ↑ delete ##############################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################
        finally:
            if touch_process: touch_process.terminate()

def start_dash_cam(): # sets camera attributes for proper output size and format before running
    runtime = DASHCAM_FPS * 60 * 30
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    format = f"width={DASHCAM_IMAGE_WIDTH},height={DASHCAM_IMAGE_HEIGHT},pixelformat=MJPG"
    bash(f"v4l2-ctl -d {camPath} -v {format}",check=False)

    local_time = localtime()
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mjpeg"
    cmd = f"v4l2-ctl -d {camPath} --stream-mmap=3 --stream-count={runtime} --stream-to={filepath}"
    return shell(cmd,text=True)

def bash(cmd:str,shell=True,capture_output=True,check=False):
    try: return run(cmd,shell=shell,capture_output=capture_output,check=check)
    except Exception as e:# logger.exception(e)
## DEBUG ################ ↑ delete ##################################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################

def shell(cmd:str,shell=True,stdout=PIPE,stderr=PIPE,**kwargs):
    return Popen(cmd,shell=shell,stdout=stdout,stderr=stderr,**kwargs)

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    handler.setLevel(logging.INFO)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    main()