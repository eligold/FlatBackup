#!/usr/bin/env python3
import traceback, logging, traceback, cv2, os
from subprocess import run, Popen, PIPE, TimeoutExpired
from time import localtime, time, perf_counter
from queue import Empty, Full, SimpleQueue
from gpiozero import CPUTemperature
from collections import deque
from threading  import Thread

from ImageConstants import *
from ELM327 import ELM327

DOT = np.full((3,3,3),SHADOW,np.uint8)
DOT[:2,:2] = (0xFF,0,0)
# camera index by device mapper path
usb_capture_id_path="/dev/v4l/by-id/usb-MACROSIL_AV_TO_USB2.0-video-index0"
usb_capture_real_path = os.path.realpath(usb_capture_id_path)
assert usb_capture_id_path != usb_capture_real_path
cameraIndex = int(usb_capture_real_path.split("video")[-1])

# communications between threads:
display_queue = SimpleQueue()
signal_queue = SimpleQueue()
sidebar_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)

## DEBUG ############################################################
show_graph = True # False
## /DEBUG ###########################################################

exit_flag = False

# calculate camera values to undistort image
new_K = cv2.fisheye.estimateNewCameraMatrixForUndistortRectify(K, D, DIM, np.eye(3), balance=1)
mapx, mapy = cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(3), new_K, DIM, cv2.CV_32FC1)
map1, map2 = cv2.convertMaps(mapx,mapy,cv2.CV_16SC2) # fixed point maps run faster

def putText(img, text, origin=(0,480), #bottom left
            color=(0xc5,0x9e,0x21),fontFace=cv2.FONT_HERSHEY_SIMPLEX,
            fontScale=1,thickness=2,lineType=cv2.LINE_AA):
    return cv2.putText(img,text,origin,fontFace,fontScale,color,thickness,lineType)

no_signal_frame = putText(
        np.full((FINAL_IMAGE_HEIGHT,FINAL_IMAGE_WIDTH,2),COLOR_BAD,np.uint8),
        "No Signal",(500,200))
frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
sidebar_base = np.full((FINAL_IMAGE_HEIGHT,SCREEN_WIDTH-FINAL_IMAGE_WIDTH,2),COLOR_LOW,np.uint8)
for i in range(160,FINAL_IMAGE_HEIGHT):
    for j in range(120):
        color = i*2&(i-255-j)
        sidebar_base[i][j] = np.uint8(color), np.uint8(color>>8)

frame_buffer[:,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:,:-SIDEBAR_WIDTH] = \
    putText(frame_buffer[:,:-120],"Initializing",(500,250),fontScale=3,thickness=4)

############## DEBUG #############
display_times = deque(maxlen=1000)
proc_times = deque(maxlen=1000)
cam_times = deque(maxlen=1000)

def sidebar_hot():
    _change_sidebar(COLOR_REC)
def sidebar_cool():
    _change_sidebar(COLOR_LOW)
def _change_sidebar(color):
    global sidebar_base
    sidebar_base[:160]=np.full((),color,np.uint8)

                                # 60.0
intemp = CPUTemperature(threshold=20.0,event_delay=0.95)
intemp.when_activated = sidebar_hot
intemp.when_deactivated = sidebar_cool

def data():
    global sidebar_queue
    global frame_buffer
    global exit_flag
    wifi_flag = False
    bluetooth_process = None
    dashcam_proc = None
    car_conn = None
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing",(500,250),
                color=COLOR_LAYM,fontScale=3,thickness=4)
    with open("/root/.btmac","r") as file: mac = file.readline()#try:
    try: # is the wifi connected?                                    \\ YOOHOO //
        if bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n': pass
           # raise KeyboardInterrupt("wifi connected") # else turn off radio to save power
        else: wifi_flag = shell('ip link set wlan0 down').wait() == 0
        bluetooth_process = shell(f"bluetoothctl connect {mac}",text=True)
        started_names = []
        for function, name in [
                (touch_input,"taps"),
                (get_image,"read"),
                (on_screen,"show")]:
            Thread(target=function,name=name,daemon=True).start()
            started_names.append(name)
        frame_buffer[:,:-SIDEBAR_WIDTH] = \
            putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing...",(500,250),
                    color=COLOR_LAYM,fontScale=3,thickness=4)
        logger.info(f'threads started: {started_names}')
        return_code = bluetooth_process.wait()
## DEBUG ############################################################
        for bt_line in bluetooth_process.stdout.readlines(): logger.info(bt_line.rstrip())
        logger.info("Bluetooth success?" if return_code == 0 else f"BT return code: {return_code}")
## /DEBUG ###########################################################
        while not exit_flag:
            return_code = 0
            dashcam_proc = start_dash_cam()
            car_conn = ELM327()
            while not exit_flag:
                make_sidebar(car_conn.psi())
                try: return_code = dashcam_proc.wait(0.095)
                except TimeoutExpired: pass
                else:
                    for dash_ln in dashcam_proc.stdout.readlines(): logger.info(dash_ln)
                    if return_code: log_dashcam_errors(dashcam_proc)
                if exit_flag: break
            if exit_flag: break
    except Exception as ex:
        if dashcam_proc: dashcam_proc.terminate()
        traceback.print_exc()
        logger.exception(ex)
    finally:# leave(dashcam_proc,wifi_flag,car_conn)
## DEBUG ## ↑ delete ################################################
        logger.info(f"display queue: {display_queue.qsize()}")
        for times,label in ((cam_times,"read"),(proc_times,"proc"),(display_times,"disp")):
            if times: logger.info(f"[{label}] time stats:\nmin: {min(times)*1000:.1f}ms\tmax: {max(times)*1000:.1f}ms\t mode:{max(times,key=times.count)*1000:.1f}ms\nmean: {np.mean(times)*1000:.1f}ms\tmedian: {np.median(times)*1000:.1f}ms")
            else: logger.error(f"timer {label} failed to init")
        leave(dashcam_proc,wifi_flag,car_conn)
## /DEBUG ###########################################################

def leave(dashcam_proc, wifi_flag, car_conn):
    global exit_flag
    exit_flag = True
    if car_conn: car_conn.close()
    if dashcam_proc: dashcam_proc.kill()
    if wifi_flag: bash('ip link set wlan0 up',check=False)

def log_dashcam_errors(dashcam_proc):
    logger.error(f"dashcam command exit code: {dashcam_proc.returncode}")
    for err_ln in dashcam_proc.stderr.readlines(): 
        logger.error(err_ln)

def make_sidebar(psi):
    global psi_list
    entry = int(psi*PPPSI)
    psi_list.append(entry)

    sidebar = sidebar_base.copy()
    sidebar = putText(sidebar,f"{psi:.1f}",(4,57),color=COLOR_NORMAL,fontScale=1.19,
            thickness=3)
    sidebar = putText(sidebar,"BAR" if psi < 0.0 else "PSI",(60,95),color=COLOR_BAD)
    sidebar_queue.put(sidebar)

def on_screen():
    global display_queue, signal_queue
    global frame_buffer
    global show_graph, exit_flag
    global proc_times

    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing..",(500,250),
                color=COLOR_LAYM,fontScale=3,thickness=4)
    while not exit_flag:

        start = perf_counter()
        try:
            image = build_output_image(display_queue.get(timeout=0.057))
            if show_graph: image = addOverlay(image)
            image = cv2.cvtColor(image, BGR565)

            proc_times.append(perf_counter()-start)

            if exit_flag: break

        except Empty:perf_counter()# pass

        else: display_image(image)
        if exit_flag: break
    print("leaving on_screen")

def display_image(image):
    global frame_buffer
    global sidebar_queue
    global display_times

    start = perf_counter()

    frame_buffer[:,:-SIDEBAR_WIDTH] = image
    try: frame_buffer[:,-SIDEBAR_WIDTH:] = sidebar_queue.get(block=False)
    except Empty: pass
    frame_buffer.flush()
    try: signal_queue.put(None)
    except Full: pass

    display_times.append(perf_counter()-start)

def get_image():
    global display_queue, signal_queue
    global exit_flag
    global cam_times
    global logger
    signal_queue.put(None)
    width, height = DIM
    camera = None
    read_fail_count = 0
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing.",(500,250),
                color=COLOR_LAYM,fontScale=3,thickness=4)
    while not exit_flag:
        try:
            camera = get_camera(cameraIndex,width,height)
            camera.read()
            while camera.isOpened() and not exit_flag:

                start = perf_counter()

                try: signal_queue.get(timeout=0.095)

                except Empty: perf_counter() # pass

                else:
                    success, image = camera.read()
                    if success:
                        try: display_queue.put(image)
                        except Full: display_image(image)

                        cam_times.append(perf_counter()-start)
                    else: # read_fail_count += 1
                        perf_counter()
                        read_fail_count += 1
        except Exception as e:
            traceback.print_exc()
            logger.exception(e)
        finally:
            if camera: camera.release()
        if exit_flag: break

    print("leaving get_image")

def touch_input():
    global show_graph, exit_flag
    touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'
    touch_process = None
    x = None
    last_time = time()
    while not exit_flag:
        try:
            touch_process = shell(touch_command,text=True)
            while not "interrupt to exit" in touch_process.stdout.readline(): pass
            while not exit_flag:
                active = False # test for only code_id = 5 to detect press and hold
                event = touchEvent(touch_process.stdout.readline())
                if event.time > last_time + 0.19: active = True
                event_list = []
                while not "-- SYN_REPORT --" in event.code: # check .valid instead
                    if active and event.isX:
                        if event.value >= FINAL_IMAGE_WIDTH: x = event.value
                        else:
                            last_time = event.time
                            active = False
                    if active and event.isY:
                        if event.value < SCREEN_HEIGHT/2: show_graph = not show_graph
                        else: raise KeyboardInterrupt(f'touch input(X →,Y ↓) -> {x},{event.value}')
                    if event.code_id != 5: logger.info(event.pretty())
                    event = touchEvent(touch_process.stdout.readline())
                if active: last_time = event.time
                x = None
                if exit_flag: break
        except KeyboardInterrupt as kbi: raise kbi
        except Exception as e:# logger.exception(e)
## DEBUG #################### ↑ delete ##############################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################
        finally:
            if touch_process: touch_process.terminate()

# make boost graph here ~+15psi to ~-1.5bar
# add each point to new deque and increment position by one when reading current deque
def addOverlay(image):
    h,w = image.shape[:2]
    radius,offset = 19,38
    overlay_image = image.copy()
    graph_list = psi_list.copy()
    overlay_image[20:461,39:1442] = COLOR_OVERLAY
    overlay_image[39:442,20:1461] = COLOR_OVERLAY
    overlay_image = cv2.circle(overlay_image,(offset,offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(offset,h-offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(w-offset,h-offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(w-offset,offset),radius,COLOR_OVERLAY,-1)
    cv2.addWeighted(overlay_image,ALPHA,image,1-ALPHA,0,image)
    image[25:455,44:46] = BLACK
    image[405:407,25:1456] = BLACK
    image[135:137,38:45] = BLACK
    image = putText(image,"10",(25,133),color=BLACK,fontScale=0.38,thickness=1)
    for x in range(PSI_BUFFER_DEPTH-len(graph_list),PSI_BUFFER_DEPTH):
        try:
            y = FDIM[1] - 2 * PPPSI - 15 - graph_list.popleft()
            image[y:y+3,x-3:x] = DOT
        except IndexError: traceback.print_exc()
    return image

def get_camera(camIndex:int,width,height,apiPreference=cv2.CAP_V4L2,brightness=25) -> cv2.VideoCapture:
    camera = cv2.VideoCapture(camIndex,apiPreference=apiPreference)
    camera.set(WIDTH,width)
    camera.set(HEIGHT,height)
    camera.set(BRIGHTNESS,brightness)
    assert EXPECTED_SIZE == (int(camera.get(WIDTH)),int(camera.get(HEIGHT)),int(camera.get(FPS)))
    return camera

def build_output_image(img): # MAYBE ALSO TRY mapx, mapy ?
    intermediate = cv2.remap(img,map1,map2,interpolation=LINEAR)
    image = cv2.resize(intermediate,SDIM,interpolation=LINEAR)[66:558]
    large = cv2.resize(image[213:453,EDGEBAR_WIDTH:-EDGEBAR_WIDTH],FDIM,interpolation=LINEAR)
    return cv2.hconcat([
            image[6:FINAL_IMAGE_HEIGHT+6,:EDGEBAR_WIDTH],
            large,
            image[:FINAL_IMAGE_HEIGHT,-EDGEBAR_WIDTH:]])

def start_dash_cam(): # sets camera attributes for proper output size and format before running
    runtime = DASHCAM_FPS * 60 * 30
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    format = f"width={DASHCAM_IMAGE_WIDTH},height={DASHCAM_IMAGE_HEIGHT},pixelformat=MJPG"
    bash(f"v4l2-ctl -d {camPath} -v {format}",check=False)

    local_time = localtime()
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mjpeg"
    cmd = f"v4l2-ctl -d {camPath} --stream-mmap=3 --stream-count={runtime} --stream-to={filepath}"
    return shell(cmd,text=True)

def bash(cmd:str,shell=True,capture_output=True,check=False):
    try: return run(cmd,shell=shell,capture_output=capture_output,check=check)
    except Exception as e:# logger.exception(e)
## DEBUG ################ ↑ delete ##################################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################

def shell(cmd:str,shell=True,stdout=PIPE,stderr=PIPE,**kwargs):
    return Popen(cmd,shell=shell,stdout=stdout,stderr=stderr,**kwargs)

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    handler.setLevel(logging.INFO)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    data()
