#!/usr/bin/env python3
import traceback, logging, traceback, cv2, os
from subprocess import run, Popen, PIPE, STDOUT, TimeoutExpired
from time import localtime, time
from queue import Empty, Full, SimpleQueue
from gpiozero import CPUTemperature
from collections import deque
from threading  import Thread

from ImageConstants import *
from ELM327 import ELM327

# camera index by device mapper path
usb_capture_id_path="/dev/v4l/by-id/usb-MACROSIL_AV_TO_USB2.0-video-index0"
usb_capture_real_path = os.path.realpath(usb_capture_id_path)
assert usb_capture_id_path != usb_capture_real_path
cameraIndex = int(usb_capture_real_path.split("video")[-1])
# communications between threads:
display_queue = SimpleQueue()
signal_queue = SimpleQueue()
sidebar_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)

show_graph = False
exit_flag = False
sidebar_lock = False
# calculate camera values to undistort image
new_K = cv2.fisheye.estimateNewCameraMatrixForUndistortRectify(K, D, DIM, np.eye(3), balance=1)
mapx, mapy = cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(3), new_K, DIM, cv2.CV_32FC1)
map1, map2 = cv2.convertMaps(mapx,mapy,cv2.CV_16SC2) # fixed point maps run faster

def putText(img, text, origin=(0,480), #bottom left
            color=(0xc5,0x9e,0x21),fontFace=cv2.FONT_HERSHEY_SIMPLEX,
            fontScale=1,thickness=2,lineType=cv2.LINE_AA):
    return cv2.putText(img,text,origin,fontFace,fontScale,color,thickness,lineType)

no_signal_frame = putText(
        np.full((FINAL_IMAGE_HEIGHT,FINAL_IMAGE_WIDTH,2),COLOR_BAD,np.uint8),
        "No Signal",(500,200))
sidebar_base = np.full((FINAL_IMAGE_HEIGHT,SCREEN_WIDTH-FINAL_IMAGE_WIDTH,2),COLOR_LOW,np.uint8)
for i in range(160,FINAL_IMAGE_HEIGHT):
    for j in range(120): sidebar_base[i][j] = np.uint8(i*2&(i-255-j)), np.uint8((i*2&(i-255-j))>>8)

frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:,:-SIDEBAR_WIDTH] = \
    putText(frame_buffer[:,:-(SCREEN_WIDTH-FINAL_IMAGE_WIDTH)], "Initializing", (500,250),
            color=COLOR_LAYM, fontScale=3, thickness=4)

def sidebar_hot():
    _change_sidebar(COLOR_REC)
def sidebar_cool():
    _change_sidebar(COLOR_LOW)
def _change_sidebar(color):
    global sidebar_base
    global sidebar_lock
    while sidebar_lock: pass
    sidebar_lock = True
    sidebar_base[:160]=np.full((160,120,2),color,np.uint8)
    sidebar_lock = False

intemp = CPUTemperature(threshold=60.0,event_delay=0.95)
intemp.when_activated = sidebar_hot
intemp.when_deactivated = sidebar_cool

def data():
    global sidebar_queue
    global frame_buffer
    started_names = []
    wifi_flag = False
    bluetooth_process = None
    dashcam_proc = None
    car_conn = None
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH], "Initializing", (500,250),
                color=COLOR_LAYM, fontScale=3, thickness=4)
    with open("/root/.btmac","r") as file: mac = file.readline()
    try: # is the wifi connected?                                    \\ YOOHOO //
        if bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n': pass
           # raise KeyboardInterrupt("wifi connected") # else turn off radio to save power
        else: wifi_flag = shell('ip link set wlan0 down').wait() == 0
        for function, name in [(touch_input,"taps"),(get_image,"read"),(on_screen,"show")]:
            Thread(target=function, name=name, daemon=True).start()
            started_names.append(name)
        frame_buffer[:,:-SIDEBAR_WIDTH] = \
            putText(frame_buffer[:,:-SIDEBAR_WIDTH], "Initializing...", (500,250),
                    color=COLOR_LAYM, fontScale=3, thickness=4)
        logger.info(f'threads started: {started_names}')
        bluetooth_process = shell(f"bluetoothctl connect {mac}", text=True)
        return_code = bluetooth_process.wait()
## DEBUG ############################################################
        for bt_line in bluetooth_process.stdout.readlines(): logger.info(bt_line.rstrip())
        logger.info("Bluetooth success?" if return_code == 0 else f"BT return code: {return_code}")
## /DEBUG ###########################################################
        while not exit_flag:
            dashcam_proc = start_dash_cam()
            car_conn = ELM327()
            while not exit_flag:
                make_sidebar(car_conn.psi())
                try: dashcam_proc.wait(0.095)
                except TimeoutExpired: pass
                else:
                    for dash_ln in dashcam_proc.stdout.readlines(): logger.info(dash_ln)
                if exit_flag: break
            if exit_flag: break
    except Exception as ex:
        if dashcam_proc: dashcam_proc.terminate()
        traceback.print_exc()
        logger.exception(ex)

        print("here!!!")

    finally: leave(dashcam_proc,wifi_flag,car_conn)

def leave(dashcam_proc, wifi_flag, car_conn):
    global exit_flag
    if exit_flag: print("exit flag set!")
    else: exit_flag = True
    if car_conn: car_conn.close()
    if dashcam_proc: dashcam_proc.kill()
    if wifi_flag: bash('ip link set wlan0 up',check=False)

def make_sidebar(psi):
    global psi_list
    global sidebar_lock
    entry = int(psi*PPPSI)
    psi_list.append(entry)
    while sidebar_lock: pass
    sidebar_lock = True
    sidebar = sidebar_base.copy()
    sidebar_lock = False
    sidebar = putText(sidebar, f"{psi:.1f}",(4,57), color=COLOR_NORMAL, fontScale=1.19, thickness=3)
    sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (60,95), color=COLOR_BAD)
    sidebar_queue.put(sidebar)

def on_screen():
    global display_queue, signal_queue
    global frame_buffer
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing..",(500,250),
                color=COLOR_LAYM,fontScale=3,thickness=4)
    while not exit_flag:
        try:
            image = build_output_image(display_queue.get(timeout=0.057))
            if show_graph: image = addOverlay(image)
            image = cv2.cvtColor(image, BGR565)
            if exit_flag: break
        except Empty: pass
        else: display_image(image)
        if exit_flag: break

def display_image(image):
    global frame_buffer
    global sidebar_queue
    frame_buffer[:,:-SIDEBAR_WIDTH] = image
    try: frame_buffer[:,-SIDEBAR_WIDTH:] = sidebar_queue.get(block=False)
    except Empty: pass
    frame_buffer.flush()
    try: signal_queue.put(None)
    except Full: pass

def get_image():
    global display_queue, signal_queue
    width, height = DIM
    camera = None
    read_fail_count = 0
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing.",(500,250),
                color=COLOR_LAYM,fontScale=3,thickness=4)
    while not exit_flag:
        signal_queue.put(None)
        try:
            camera = get_camera(cameraIndex,width,height)
            camera.read()
            while camera.isOpened() and not exit_flag:
                try: signal_queue.get(timeout=0.095)
                except Empty: pass
                else:
                    success, image = camera.read()
                    if success: # SimpleQueue never blocks
                        try: display_queue.put(image)
                        except Full: display_image(image)
                    else: read_fail_count += 1
        except Exception as e: logger.exception(e)
        finally:
            if camera: camera.release()
        if exit_flag: break

def touch_input():
    global show_graph, exit_flag
    touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'
    touch_process = None
    last_time = time()
    while not exit_flag:
        x = None
        try:
            touch_process = shell(touch_command,text=True)
            while not "interrupt to exit" in touch_process.stdout.readline(): pass
            while not exit_flag:
                active = False # test for only code_id = 5 to detect press and hold
                event = touchEvent(touch_process.stdout.readline())
                try:
                    if event.time > last_time + 0.19: active = True
                except: print(event.code)
                while not "-- SYN_REPORT --" in event.code: # check .valid instead
                    if active and event.isX:
                        if event.value >= FINAL_IMAGE_WIDTH: x = event.value
                        else:
                            last_time = event.time
                            active = False
                    if active and event.isY and x is not None:
                        if event.value < SCREEN_HEIGHT/2: show_graph = not show_graph
                        else: raise KeyboardInterrupt(f'touch input(X →,Y ↓) -> {x},{event.value}')
                    if event.code_id != 5: logger.info(event.pretty())
                    event = touchEvent(touch_process.stdout.readline())
                if active: last_time = event.time
                x = None
                if exit_flag: break
        except KeyboardInterrupt as kbi: 
            exit_flag = True
            raise kbi
        except Exception as e:# logger.exception(e)
## DEBUG #################### ↑ delete ##############################
            traceback.print_exc()
            logger.exception(e)
## /DEBUG ###########################################################
        finally:
            if touch_process: touch_process.terminate()

# make boost graph here ~+15psi to ~-1.5bar
# add each point to new deque and increment position by one when reading current deque
def addOverlay(image):
    h,w = image.shape[:2]
    radius,offset = 19,38
    overlay_image = image.copy()
    graph_list = psi_list.copy()
    overlay_image[20:461,39:1442] = COLOR_OVERLAY
    overlay_image[39:442,20:1461] = COLOR_OVERLAY
    overlay_image = cv2.circle(overlay_image,(offset,offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(offset,h-offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(w-offset,h-offset),radius,COLOR_OVERLAY,-1)
    overlay_image = cv2.circle(overlay_image,(w-offset,offset),radius,COLOR_OVERLAY,-1)
    cv2.addWeighted(overlay_image,ALPHA,image,1-ALPHA,0,image)
    image[25:455,44:46] = BLACK
    image[405:407,25:1456] = BLACK
    image[135:137,38:45] = BLACK
    image = putText(image,"10",(25,133),color=BLACK,fontScale=0.38,thickness=1)
    for x in range(PSI_BUFFER_DEPTH-len(graph_list),PSI_BUFFER_DEPTH):
        try:
            y = FDIM[1] - 2 * PPPSI - 15 - graph_list.popleft()
            image[y:y+3,x-3:x] = DOT
        except IndexError: traceback.print_exc()
    return image

def get_camera(camIndex:int,width,height,apiPreference=cv2.CAP_V4L2,brightness=25) -> cv2.VideoCapture:
    camera = cv2.VideoCapture(camIndex,apiPreference=apiPreference)
    camera.set(WIDTH,width)
    camera.set(HEIGHT,height)
    camera.set(BRIGHTNESS,brightness)
    assert EXPECTED_SIZE == (int(camera.get(WIDTH)),int(camera.get(HEIGHT)),int(camera.get(FPS)))
    return camera

def build_output_image(img): # MAYBE ALSO TRY mapx, mapy ?
    height, width = FINAL_IMAGE_HEIGHT, EDGEBAR_WIDTH
    intermediate = cv2.remap(img,map1,map2,interpolation=LINEAR)
    image = cv2.resize(intermediate,SDIM,interpolation=LINEAR)[66:558]
    large = cv2.resize(image[213:453,width:-width],FDIM,interpolation=LINEAR)
    return cv2.hconcat([image[6:height+6,:width], large, image[:height,-width:]])

def start_dash_cam(): # sets camera attributes for proper output size and format before running
    runtime = DASHCAM_FPS * 60 * 30
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    format = f"width={DASHCAM_IMAGE_WIDTH},height={DASHCAM_IMAGE_HEIGHT},pixelformat=MJPG"
    bash(f"v4l2-ctl -d {camPath} -v {format}",check=False)
    local_time = localtime()
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mjpeg"
    cmd = f"v4l2-ctl -d {camPath} --stream-mmap=3 --stream-count={runtime} --stream-to={filepath}"
    return shell(cmd,stderr=STDOUT,text=True)

def bash(cmd:str,shell=True,capture_output=True,check=False):
    try: return run(cmd,shell=shell,capture_output=capture_output,check=check)
    except Exception as e: logger.exception(e)

def shell(cmd:str,shell=True,stdout=PIPE,stderr=PIPE,**kwargs):
    return Popen(cmd,shell=shell,stdout=stdout,stderr=stderr,**kwargs)

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    handler.setLevel(logging.INFO)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    data()
