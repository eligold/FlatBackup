#!/usr/bin/env python3
import traceback, logging
from subprocess import run, Popen, PIPE, TimeoutExpired
from gpiozero import CPUTemperature
from threading  import Thread
from time import localtime
from ELM327 import ELM327
from ImageProc import *

                                # 60.0
intemp = CPUTemperature(threshold=20.0,event_delay=0.95)
intemp.when_activated = sidebar_hot
intemp.when_deactivated = sidebar_cool
touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'

def main():
    global exit_flag
    wifi_flag = False
    bluetooth_process = None
    dashcam_proc = None
    with open("/root/.btmac","r") as file: mac = file.readline()
    bluetoothctl_lines = [
            'bluetoothctl << EOF',
            f'connect {mac}',
           # f'info {mac}',
            'EOF']

    try: # is the wifi connected?                                    \\ YOOHOO //
        if bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n': pass
           # raise KeyboardInterrupt("wifi connected") # else turn off radio to save power
        else: wifi_flag = shell('ip link set wlan0 down').wait() == 0
        bluetooth_process = shell(f"bluetoothctl connect {mac}") # '\n'.join(bluetoothctl_lines))
        started_names = []
        for function, name in [
                (get_image,"read"),
                (on_screen,"show"),
                (sidebar_builder_touch,"data")]:
            Thread(target=function,name=name,daemon=True).start()
            started_names.append(name)
        logger.info(f'threads started: {started_names}')
        return_code = bluetooth_process.wait()
        for bt_line in bluetooth_process.stdout.readlines():
            logger.info(bt_line.decode())
        logger.info("Bluetooth success?" if return_code == 0 else f"BT return code: {return_code}")
        while not exit_flag:
            return_code = 0
            dashcam_proc = start_dash_cam()
            while not exit_flag:
                try: return_code = dashcam_proc.wait(1.9)
                except TimeoutExpired: pass
                else:
                    for dash_ln in dashcam_proc.stdout.readlines(): logger.info(dash_ln.decode())
                    if return_code: 
                        logger.error(f"dashcam command exit code: {dashcam_proc.returncode}")
                        for err_ln in dashcam_proc.stderr.readlines(): 
                            logger.error(err_ln.decode())
    except Exception as ex:
        if dashcam_proc: dashcam_proc.terminate()
        traceback.print_exc()
        logger.exception(ex)
    finally:
        exit_flag = True

        logger.info(f"display queue: {display_queue.qsize()}")
        for times,label in ((cam_times,"read"),(proc_times,"proc"),(display_times,"disp")):
            if times: logger.info(f"[{label}] time stats:\nmin: {min(times)*1000:.1f}ms\tmax: {max(times)*1000:.1f}ms\t mode:{max(times,key=times.count)*1000:.1f}ms\nmean: {np.mean(times)*1000:.1f}ms\tmedian: {np.median(times)*1000:.1f}ms")
            else: logger.error(f"timer {label} failed to init")

        if dashcam_proc: dashcam_proc.kill()
        if wifi_flag: bash('ip link set wlan0 up',check=False)

def sidebar_builder_touch():
    global sidebar_queue
    global frame_buffer
    touch_process = None
    stdout = None
    car_conn = None
    frame_buffer[:,:-SIDEBAR_WIDTH] = \
        putText(frame_buffer[:,:-SIDEBAR_WIDTH],"Initializing...",(500,250),fontScale=3,thickness=4)
    while not exit_flag:
        try:
            car_conn = ELM327()
            touch_process = shell(touch_command)
            stdout = touch_process.stdout
            while not exit_flag:
                make_sidebar(car_conn.psi())
                touch_input(stdout)
        except Exception as e:# logger.exception(e)
            traceback.print_exc()
            logger.exception(e)
        finally:
            if car_conn: car_conn.close()
            if stdout: stdout.close()
            if touch_process: touch_process.terminate()
            if touch_process: touch_process.kill()
 
def touch_input(stdout):
    global show_graph
    for line in iter(stdout.readline,''):
        line = line.decode()
        if("POSITION_X" in line and "value" in line):
            x = int(line.split("value")[-1])
            if x >= FINAL_IMAGE_WIDTH:
                line = stdout.readline().decode()
                y = int(line.split("value")[-1])
                if y > 239: raise KeyboardInterrupt(f'touch input ( X: > , Y: v ) {x} , {y}')
                else: show_graph = ~show_graph

def start_dash_cam(): # sets camera attributes for proper output size and format before running
    runtime = DASHCAM_FPS * 60 * 30
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    format = f"width={DASHCAM_IMAGE_WIDTH},height={DASHCAM_IMAGE_HEIGHT},pixelformat=MJPG"
    bash(f"v4l2-ctl -d {camPath} -v {format}",check=False)

    local_time = localtime()
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mjpeg"
    cmd = f"v4l2-ctl -d {camPath} --stream-mmap=3 --stream-count={runtime} --stream-to={filepath}"
    return shell(cmd)

def bash(cmd:str,shell=True,capture_output=True,check=False):
    try: return run(cmd,shell=shell,capture_output=capture_output,check=check)
    except Exception as e:# logger.exception(e)
        logger.exception(e)
        traceback.print_exc()

def shell(cmd:str,shell=True,stdout=PIPE,stderr=PIPE):
    return Popen(cmd,shell=shell,stdout=stdout,stderr=stderr)

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    handler.setLevel(logging.INFO)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    main()
