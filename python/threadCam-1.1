#!/usr/bin/env python3
import logging, os, traceback
from queue import Empty, Full, SimpleQueue
# from v4l2py import Device, VideoCapture
from subprocess import TimeoutExpired
from gpiozero import CPUTemperature
from evdev import InputDevice
from collections import deque
from threading  import Thread
from time import time

from Constants import *
from ELM327 import ELM327

# camera index by device mapper path
usb_capture_id_path="/dev/v4l/by-id/usb-MACROSIL_AV_TO_USB2.0-video-index0"
usb_capture_real_path = os.path.realpath(usb_capture_id_path)
assert usb_capture_id_path != usb_capture_real_path
cameraIndex = int(usb_capture_real_path.split("video")[-1])
# communications between threads:
sidebar_queue = SimpleQueue()
display_queue = SimpleQueue()
signal_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)

show_graph = False
exit_flag = False
HIGH_TEMP = 55.0

sidebar_hot = cv.cvtColor(cv.imread("/root/turboSB_hot.png"),BGR565)[-160:,:120]
sidebar_cool = cv.cvtColor(cv.imread("/root/turboSB.png"),BGR565)[-160:,:120]
def _sidebar_hot():
    logger.warning(f"temp over {int(HIGH_TEMP)}C")
    _change_sidebar(sidebar_hot)
def _change_sidebar(img=sidebar_cool):
    global sidebar_base
    sidebar_base=img.copy()
_change_sidebar()

intemp = CPUTemperature(threshold=HIGH_TEMP,event_delay=1.9)
intemp.when_activated = _sidebar_hot
intemp.when_deactivated = _change_sidebar

frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:160,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)

with open("/root/.btmac","r") as file: mac = file.readline()

def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))

def _wifi_state():
    return bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n'

def data():
    global exit_flag
    global show_graph
    dashcam_process, car_connection, touch_input_device, x = None, None, None, None
    bt_time = time() + 5
    touch_time = time() + 0.19
    started_names = []
    try: frame_buffer[160:,-SIDEBAR_WIDTH:] = cv.cvtColor(
        cv.imread("/root/newSidebar.png")[1:],BGR565)
    except: logger.warning("couldn't find sidebar!")
    try: # is the wifi connected?
        if _wifi_state(): pass # raise KeyboardInterrupt("wifi connected")
        else: bash('ip link set wlan0 down') # else turn off radio to save power
        for function, name in [(get_image,"read"),(on_screen,"show")]: # (touch_runner,"taps"),
            Thread(target=function, name=name, daemon=True).start()
            started_names.append(name)
        _show_message("Initializing...", (500,250))
        logger.info(f'threads started: {started_names}')
        touch_dev_path = "/dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00"
        while not exit_flag:
            dashcam_process = start_dash_cam()
            car_connection = ELM327()
            while not exit_flag:
                make_sidebar(car_connection.psi())
                if exit_flag: break
                if time() > touch_time:
                    try:
                        if touch_input_device is None: touch_input_device = InputDevice(touch_dev_path)
                        for event in touch_input_device.read():
                            if event.type == 3:
                                if event.code == 0 and event.value > FINAL_IMAGE_WIDTH:
                                    x = event.value
                                else:
                                    if x is not None and event.code == 1:
                                        if event.value > SCREEN_HEIGHT/2:
                                            msg = f'touch input(X ⇁,Y ⇃) -> {x},{event.value}'
                                            logger.info(msg)
                                            raise KeyboardInterrupt()
                                        else: show_graph = not show_graph
                                    x = None
                    except BlockingIOError: pass # no new input
                    except (OSError, FileNotFoundError):
                        if touch_input_device is not None:
                            touch_input_device.close()
                            touch_input_device = None
                        touch_time = time() + 0.38
                if bt_time is not None and time() > bt_time:
                    bash(f"bluetoothctl connect {mac}")
                    bt_time = None
                try: dashcam_process.wait(0.095)
                except TimeoutExpired: pass
                else:
                    logger.info(dashcam_process.stdout.readlines())
                    dashcam_process = start_dash_cam()
            if exit_flag: break
    except KeyboardInterrupt: exit_flag = True
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)
    finally: leave(dashcam_process, car_connection, touch_input_device)

def leave(dashcam_process, car_connection, touch_input_device):
    global exit_flag
    if not exit_flag: exit_flag = True
    if touch_input_device is not None: touch_input_device.close()
    if dashcam_process is not None: dashcam_process.terminate()
    if car_connection  is not None: car_connection.close()
    if dashcam_process is not None: dashcam_process.kill()
    if not _wifi_state(): Popen("sync; sync; sync; sleep 0.19; shutdown -h now",shell=True) # bash('ip link set wlan0 up')
    else: bash(f"bluetoothctl disconnect {mac}")
   # Popen("shutdown -h now",shell=True)


def make_sidebar(psi):
    global psi_list
    try:
        entry = max(FDIM[1] - 2 * PPPSI - 15 - int(psi*PPPSI),1)
        psi_list.append(entry)
        sidebar = sidebar_base.copy()
        sidebar = \
                putText(sidebar, f"{psi:.1f}",(4,38), color=COLOR_NORMAL, fontScale=1.19, thickness=3)
        sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (42,76), color=COLOR_BAD)
        sidebar_queue.put(sidebar)
    except Exception as e: logger.exception(e)

def on_screen(display_queue=display_queue):
    global exit_flag
    _show_message("Initializing..", (500,250))
    check_time = time() + 5
    while not exit_flag:
        try:
            image = build_output_image(display_queue.get(timeout=0.057))
            if show_graph: image = addOverlay(image)
            image = cv.cvtColor(image, BGR565)
            if exit_flag: break
        except Empty:
            if time() > check_time: logger.error("dropped frame!")
        except Exception as e: logger.exception(e)
        else: display_image(image)
        if exit_flag: break

def build_graph(graph_list, depth=PSI_BUFFER_DEPTH):
    coordinates=np.column_stack((np.array(graph_list),np.arange(depth-len(graph_list)+1,depth+1)))
    for i in range(4): frame_buffer[coordinates[:, 0]-1+i//2, coordinates[:, 1]-1+i%2] = (0xf8,0)
    for i in range(1,4): frame_buffer[coordinates[:, 0]+i//2, coordinates[:, 1]+i%2] = (0x30,0x21)

def display_image(image, sidebar_queue=sidebar_queue, signal_queue=signal_queue):
    try:
        frame_buffer[:,:-SIDEBAR_WIDTH] = image
        try: frame_buffer[:SIDEBAR_HEIGHT,-SIDEBAR_WIDTH:] = sidebar_queue.get(block=False)
        except Empty: pass
        if show_graph: build_graph(psi_list.copy())
        frame_buffer.flush()
    except Exception as e: logger.exception(e)
    try: signal_queue.put(None)
    except Full: pass

def get_image(display_queue=display_queue, signal_queue=signal_queue):
    width, height = DIM
    read_fail_count = 0
    global exit_flag
    camera = None
    _show_message("Initializing.", (500,250))
    while not exit_flag:
        signal_queue.put(None)
        try:
            camera = get_camera(cameraIndex,width,height)
            camera.read()
            while camera.isOpened() and not exit_flag:
                try: signal_queue.get(timeout=0.19)
                except Empty: logger.error("signal queue empty!")
                else:
                    success, image = camera.read()
                    if success: # SimpleQueue never blocks
                        try: display_queue.put(image)
                        except Full:
                            logger.error("display queue full!")
                            display_image(image)
                    else: read_fail_count += 1
        except Exception as e: logger.exception(e)
        finally:
            if camera: camera.release()
        if exit_flag: break

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    level = logging.DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    data()
