#!/usr/bin/env python3
import logging, os, asyncio
from queue import Empty, Full, SimpleQueue
from v4l2py import Device, VideoCapture
from subprocess import TimeoutExpired
from gpiozero import CPUTemperature
from collections import deque
from threading  import Thread
from time import time

from ImageConstants import *
from ELM327 import ELM327

# camera index by device mapper path
usb_capture_id_path="/dev/v4l/by-id/usb-MACROSIL_AV_TO_USB2.0-video-index0"
usb_capture_real_path = os.path.realpath(usb_capture_id_path)
assert usb_capture_id_path != usb_capture_real_path
cameraIndex = int(usb_capture_real_path.split("video")[-1])
# communications between threads:
display_queue = SimpleQueue()
signal_queue = SimpleQueue()
sidebar_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)

show_graph = False
exit_flag = False
HIGH_TEMP = 55.0

def _sidebar_hot():
    logger.warning(f"temp over {int(HIGH_TEMP)}C")
    _change_sidebar(COLOR_REC)
def _change_sidebar(color=COLOR_LOW):
    global sidebar_base
    sidebar_base=np.full((SIDEBAR_HEIGHT,SIDEBAR_WIDTH,2),color,np.uint8)
_change_sidebar()

intemp = CPUTemperature(threshold=HIGH_TEMP,event_delay=1.9)
intemp.when_activated = _sidebar_hot
intemp.when_deactivated = _change_sidebar

frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:160,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)

with open("/root/.btmac","r") as file: mac = file.readline()

def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))

def _wifi_state():
    return bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n'

def data(frame_buffer=frame_buffer, exit_flag=exit_flag):
    dashcam_process, car_connection = None, None
    bt_time = time() + 5
    started_names = []
    try: frame_buffer[160:,-SIDEBAR_WIDTH:] = cv.cvtColor(cv.imread("/root/newSidebar.png")[1:],BGR565)
    except: logger.warning("couldn't find sidebar!")
    try: # is the wifi connected?
        if _wifi_state(): pass # raise KeyboardInterrupt("wifi connected")
        else: bash('ip link set wlan0 down') # else turn off radio to save power
        for function, name in [(touch_input,"taps"),(get_image,"read"),(on_screen,"show")]:
            Thread(target=function, name=name, daemon=True).start()
            started_names.append(name)
        _show_message("Initializing....", (500,250))
        logger.info(f'threads started: {started_names}')
        while not exit_flag:
            dashcam_process = start_dash_cam()
            car_connection = ELM327()
            while not exit_flag:
                make_sidebar(car_connection.psi())
                if exit_flag: break
                if bt_time is not None and time() > bt_time:
                    bash(f"bluetoothctl connect {mac}")
                    bt_time = None
                try: dashcam_process.wait(0.095)
                except TimeoutExpired: pass
                else:
                    logger.info(dashcam_process.stdout.readlines())
                    dashcam_process = start_dash_cam()
                print(exit_flag)
            if exit_flag: break
    except KeyboardInterrupt: exit_flag = True
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)

        print("here!!!")

    finally: leave(dashcam_process, car_connection)

def leave(dashcam_process, car_connection , exit_flag=exit_flag):
    if not exit_flag: exit_flag = True
    if dashcam_process is not None: dashcam_process.terminate()
    if car_connection  is not None: car_connection .close()
    if dashcam_process is not None: dashcam_process.kill()
    if not _wifi_state(): bash('ip link set wlan0 up')
    bash(f"bluetoothctl disconnect {mac}")
   # Popen("shutdown -h now",shell=True)


def make_sidebar(psi):
    global psi_list
    try:
        entry = max(FDIM[1] - 2 * PPPSI - 15 - int(psi*PPPSI),1)
        psi_list.append(entry)
        sidebar = sidebar_base.copy()
        sidebar = \
                putText(sidebar, f"{psi:.1f}",(4,57), color=COLOR_NORMAL, fontScale=1.19, thickness=3)
        sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (38,95), color=COLOR_BAD)
        sidebar_queue.put(sidebar)
    except Exception as e: logger.exception(e)

def on_screen(display_queue=display_queue):
    _show_message("Initializing...", (500,250))
    check_time = time() + 5
    while not exit_flag:
        try:
            image = build_output_image(display_queue.get(timeout=0.057))
            if show_graph: image = addOverlay(image)
            image = cv.cvtColor(image, BGR565)
            if exit_flag: break
        except Empty:
            if time() > check_time: logger.error("dropped frame!")
        except Exception as e: logger.exception(e)
        else: display_image(image)
        if exit_flag: break

def build_graph(graph_list, depth=PSI_BUFFER_DEPTH):
    coordinates=np.column_stack((np.array(graph_list),np.arange(depth-len(graph_list)+1,depth+1)))
    for i in range(4): frame_buffer[coordinates[:, 0]-1+i//2, coordinates[:, 1]-1+i%2] = (0xf8,0)
    frame_buffer[coordinates[:, 0]+1, coordinates[:, 1]+1] = (0x30,0x21) # SHADOW
    frame_buffer[coordinates[:, 0]+1, coordinates[:, 1]] = (0x30,0x21)
    frame_buffer[coordinates[:, 0], coordinates[:, 1]+1] = (0x30,0x21)

def display_image(image,sidebar_queue=sidebar_queue,signal_queue=signal_queue):
    try:
        frame_buffer[:,:-SIDEBAR_WIDTH] = image
        try: frame_buffer[:SIDEBAR_HEIGHT,-SIDEBAR_WIDTH:] = sidebar_queue.get(block=False)
        except Empty: pass
        if show_graph: build_graph(psi_list.copy())
        frame_buffer.flush()
        try: signal_queue.put(None)
        except Full: pass
    except Exception as e: logger.exception(e)

def get_image():
    global display_queue, signal_queue
    width, height = DIM
    camera = None
    read_fail_count = 0
    _show_message("Initializing..", (500,250))
    while not exit_flag:
        signal_queue.put(None)
        try:
            camera = get_camera(cameraIndex,width,height)
            camera.read()
            while camera.isOpened() and not exit_flag:
                try: signal_queue.get(timeout=0.19)
                except Empty as e: logger.exception(e)
                else:
                    success, image = camera.read()
                    if success: # SimpleQueue never blocks
                        try: display_queue.put(image)
                        except Full:
                            logger.error("display queue full!")
                            display_image(image)
                    else: read_fail_count += 1
        except Exception as e: logger.exception(e)
        finally:
            if camera: camera.release()
        if exit_flag: break

def touch_input():
    global show_graph, exit_flag
    touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'
    touch_process = None
    last_time = time()
    _show_message("Initializing.", (500,250))
    while not exit_flag:
        x = None
        try:
            touch_process = shell(touch_command, text=True)
            while not "interrupt to exit" in touch_process.stdout.readline(): pass
            while not exit_flag:
                active = False # test for only code_id = 5 to detect press and hold
                event = touchEvent(touch_process.stdout.readline())
                try:
                    if event.time > last_time + 0.19: active = True
                except: print(event.code)
                while not "-- SYN_REPORT --" in event.code: # check .valid instead
                    if active and event.isX:
                        if event.value >= FINAL_IMAGE_WIDTH: x = event.value
                        else:
                            last_time = event.time
                            active = False
                    if active and event.isY and x is not None:
                        if event.value < SCREEN_HEIGHT/2: 
                            show_graph = not show_graph
                            print(show_graph)
                        else: raise KeyboardInterrupt(f'touch input(X ⇁,Y ⇃) -> {x},{event.value}')
                    if event.code_id != 5: logger.info(event.pretty())
                    event = touchEvent(touch_process.stdout.readline())
                if active: last_time = event.time
                x = None
                if exit_flag: break
        except KeyboardInterrupt as kbi: 
            exit_flag = True
            raise kbi
        except Exception as e: logger.exception(e)
        finally:
            if touch_process is not None: touch_process.terminate()

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    level = logging.DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    data()
