#!/usr/bin/env python3
import traceback, logging, numpy as np
from subprocess import run, Popen, PIPE
from gpiozero import CPUTemperature
from threading  import Thread
from time import localtime
from ELM327 import ELM327
from ImageProc import *

                                # 60.0
intemp = CPUTemperature(threshold=20.0,event_delay=1.0)
intemp.when_activated = sidebar_hot
intemp.when_deactivated = sidebar_cool

def add_pressure(pressure):
    global psi_list
    entry = int(pressure*PPPSI)
    while(len(deque)>=PSI_BUFFER_DEPTH-1): psi_list.pop()
    psi_list.appendleft(entry)
    return pressure

def bash(cmd:str,shell=True,capture_output=True,check=False):
    try: return run(cmd,shell=shell,capture_output=capture_output,check=check)
    except Exception as e: logger.exception(e)

def shell(cmd:str,shell=True,stdout=PIPE,stderr=PIPE):
    return Popen(cmd,shell=shell,stdout=stdout,stderr=stderr)

def main():
    global exit_flag
    wifi_flag = False
    threads = []
    with open("/root/.btmac","r") as file:
        mac = file.readline()
    bluetoothctl_lines = [
            'bluetoothctl << EOF',
            f'connect {mac}',
           # f'info {mac}',
            'EOF']
    bluetooth_process = None
    dashcam_process = None
    try: # is the wifi connected?
        wifi_process = bash('cat /sys/class/net/wlan0/operstate')
        if wifi_process.stdout == b'up\n':# raise KeyboardInterrupt("wifi connected")
            pass 
        else: # turn off radio, no need to waste power
            wifi_flag = shell('ip link set wlan0 down').wait() == 0
            bluetooth_process = shell('\n'.join(bluetoothctl_lines)) # f"bluetoothctl connect {mac}")
        started_names = []
        for function, name in [
                (get_image,"read"),
                (on_screen,"show"),
                (sidebar_builder_touch,"data")]:
            thread = Thread(target=function,name=name)
            thread.start()          # start each thread
            threads.append(thread)  # store them for termination later
            started_names.append(name)
        logger.info(f'threads started: {started_names}')
        if bluetooth_process:
            ret = bluetooth_process.wait()
            for bt_line in bluetooth_process.stdout.readlines():
                logger.info(bt_line.decode())
            logger.info("Bluetooth success?" if ret == 0 else f"BT return code: {ret}")
        while not exit_flag:
            dashcam_process = start_dash_cam()
            dashcam_process.wait()
            for dash_line in dashcam_process.stdout.readlines():
                logger.info(dash_line.decode())
            logger.info(f"dashcam command exit code: {dashcam_process.returncode}")
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)
    finally:
        exit_flag = True
        logger.info(f"display queue: {display_queue.qsize()}")
        for times,label in ((cam_times,"read"),(proc_times,"proc"),(display_times,"disp")):
            if times: logger.info(f"[{label}] time stats:\nmin: {min(times)*1000:.1f}ms\tmax: {max(times)*1000:.1f}ms\t mode:{max(times,key=times.count)*1000:.1f}ms\nmean: {np.mean(times)*1000:.1f}ms\tmedian: {np.median(times)*1000:.1f}ms")
            else: logger.error(f"timer {label} failed to init")
        if dashcam_process: dashcam_process.terminate()
        if wifi_flag: bash('ip link set wlan0 up',check=False)
        for thread in threads: thread.join()

def sidebar_builder_touch():
    global sidebar_queue
    touch_process = None
    stdout = None
    touch_command = 'evtest /dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00'
    car_conn = None
    while not exit_flag:
        try:
            car_conn = ELM327()
            touch_process = shell(touch_command)
            stdout = touch_process.stdout
            while not exit_flag:
                make_sidebar(add_pressure(car_conn.psi()))
                touch_input(stdout)
        finally:
            if car_conn: car_conn.close()
            if stdout: stdout.close()
            if touch_process: touch_process.terminate()
 
def touch_input(stdout):
    global show_graph
    for line in iter(stdout.readline,''):
        line = line.decode()
        if("POSITION_X" in line and "value" in line):
            x = int(line.split("value")[-1])
            if x >= FINAL_IMAGE_WIDTH:
                line = stdout.readline().decode()
                y = int(line.split("value")[-1])
                if y > 239: raise KeyboardInterrupt(f'touch input ( X: > , Y: v ) {x} , {y}')
                else: show_graph = ~show_graph

def start_dash_cam(): # sets camera attributes for proper output size and format before running
    runtime = DASHCAM_FPS * 60 * 30
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    format = f"width={DASHCAM_IMAGE_WIDTH},height={DASHCAM_IMAGE_HEIGHT},pixelformat=MJPG"
    bash(f"v4l2-ctl -d {camPath} -v {format}",check=False)

    local_time = localtime()
    date = f"{local_time.tm_year}-{local_time.tm_mon:02d}-{local_time.tm_mday:02d}"
    clock_time = f"{local_time.tm_hour:02d}.{local_time.tm_min:02d}.{local_time.tm_sec:02d}"
    weekday = (lambda i : ['Mo','Tu','We','Th','Fr','Sa','Su'][i])(local_time.tm_wday)
    filepath = f"/media/usb/{'_'.join([date,clock_time,weekday])}.mjpeg"
    cmd = f"v4l2-ctl -d {camPath} --stream-mmap=3 --stream-count={runtime} --stream-to={filepath}"
    return shell(cmd)

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    handler.setLevel(logging.INFO)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    main()
