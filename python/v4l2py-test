#!/usr/bin/env python3
import logging, traceback, code
from queue import Empty, Full, SimpleQueue
from v4l2py import Device, VideoCapture
from evdev import InputDevice
from threading  import Thread
from time import time

from Constants import *

dash_signal_queue = SimpleQueue()
dashcam_queue = SimpleQueue()
display_queue = SimpleQueue()

exit_flag = False

frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)

def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))

def _wifi_state():
    return bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n'

def data():
    global exit_flag
    touch_input_device, x = None, None
    touch_time = time() + 0.19
    started_names = []
    try: # is the wifi connected?
        if _wifi_state(): pass # raise KeyboardInterrupt("wifi connected")
        else: bash('ip link set wlan0 down') # else turn off radio to save power
        for function, name in [(get_dash_image,"dash"), (save_video,"save"),(on_screen,"show")]:
            Thread(target=function, name=name, daemon=True).start()
            started_names.append(name)
        _show_message("Initializing...", (500,250))
        logger.info(f'threads started: {started_names}')
        touch_dev_path = "/dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00"
        while not exit_flag:
            if time() > touch_time:
                try:
                    if touch_input_device is None: touch_input_device = InputDevice(touch_dev_path)
                    for event in touch_input_device.read():
                        if event.type == 3:
                            if event.code == 0 and event.value > FINAL_IMAGE_WIDTH:
                                x = event.value
                            else:
                                if x is not None and event.code == 1:
                                    if event.value > SCREEN_HEIGHT/2:
                                        msg = f'touch input(X ⇁,Y ⇃) -> {x},{event.value}'
                                        logger.info(msg)
                                        raise KeyboardInterrupt()
                                    # else: show_graph = not show_graph
                                x = None
                except BlockingIOError: pass # no new input
                except (OSError, FileNotFoundError): # janky mcu is ailing
                    if touch_input_device is not None:
                        touch_input_device.close()
                        touch_input_device = None
                    touch_time = time() + 0.38
    except KeyboardInterrupt: exit_flag = True
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)
    finally: leave(touch_input_device)

def leave(touch_input_device):
    global exit_flag
    if not exit_flag: exit_flag = True
    if touch_input_device is not None: touch_input_device.close()
    if not _wifi_state(): Popen("sync; sync; sync; sleep 0.19; shutdown -h now",shell=True) # bash('ip link set wlan0 up')

def on_screen(display_queue=display_queue):
    global exit_flag
    _show_message("Initializing..", (500,250))
    check_time = time() + 5
    while not exit_flag:
        try:
            image = cv.resize(display_queue.get(timeout=0.057),(640,480),LINEAR)
            image = cv.cvtColor(image, BGR565)
            if exit_flag: break
        except Empty:
            if time() > check_time: logger.error("dropped frame!")
        except Exception as e: logger.exception(e)
        else: 
            frame_buffer[:,-640:] = image
            frame_buffer.flush()
        if exit_flag: break

def get_dash_image(width=DASHCAM_IMAGE_WIDTH, height=DASHCAM_IMAGE_HEIGHT, video_format="MJPG"):
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    global exit_flag
    _show_message("Initializing.", (500,250))
    while not exit_flag:
        dash_signal_queue.put(None)
        try:
            with Device.from_id(extract_index(camPath)) as cam:
                video_capture = VideoCapture(cam)
                video_capture.set_format(width,height,video_format)
                with video_capture as stream:
                    for frame in stream:
                        while not exit_flag:
                            try: dash_signal_queue.get(timeout=0.19)
                            except Empty: pass
                            else: break
                        if exit_flag: break
                        if video_format == "MJPG": image = cv.imdecode(frame.array, COLOR)
                        else: image = cv.cvtColor(frame.array.reshape(height, width, 2), YUYV)
                        try: dashcam_queue.put(image)
                        except Full: logger.error("dash queue full!")
                        try: display_queue.put(image)
                        except Full: logger.error("display queue full!")
        except Exception as e: logger.exception(e)

def save_video(queue=dashcam_queue, signal_queue=dash_signal_queue, camera=None,
               width=DASHCAM_IMAGE_WIDTH, height=DASHCAM_IMAGE_HEIGHT,fps=15):
    fourcc = cv.VideoWriter_fourcc(*'H264')
    breakout = False
    output = None
    if camera is None: _show_message("Initializing...")
    while not (exit_flag and breakout):
        try:
            output = cv.VideoWriter(get_video_path(camera), fourcc, fps, (width, height))
            while not exit_flag:
                try: image = queue.get(timeout=0.095)
                except Empty: pass
                else:
                    breakout = (image is None and camera is not None)
                   # if speed: pass # (speed,frame_num) -> csv file
                    if breakout or exit_flag: break
                    if camera is None:
                        try:
                            print("s",end="")
                            signal_queue.put(None)
                        except Full: logger.error("dashcam signal queue full!")
                    if image is not None:
                        print("w",end="")
                        output.write(image)
                    else: print("empty image!")
        except Exception as e: logger.exception(e)
        finally:
            if output is not None: output.release()

if __name__ == "__main__":
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-v4l2-test.log")
    level = logging.DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler) # turn off red LED
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    Thread(target=data, name='data', daemon=True).start()
    code.interact(local=dict(globals(), **locals()))
