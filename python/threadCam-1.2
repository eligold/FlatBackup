#!/usr/bin/env python3
import logging, os, traceback
from multiprocessing import Process, Pipe, set_start_method
from queue import SimpleQueue, Empty
from v4l2py import Device, VideoCapture
from gpiozero import CPUTemperature
from evdev import InputDevice
from collections import deque
from threading import Thread
from time import time

from Constants import *
from ELM327 import ELM327

# communications between threads:
sidebar_queue = SimpleQueue()
psi_list = deque(maxlen=PSI_BUFFER_DEPTH)
# communications between processes:
dash_pipe1, dash_pipe2 = Pipe()
backup_pipe1, backup_pipe2 = Pipe()
save_pipe1, save_pipe2 = Pipe()
main_pipe1, main_pipe2 = Pipe()

show_graph = False
exit_flag = False
HIGH_TEMP = 55.0
FRAME_DELAY = 0.119

sidebar_hot = cv.cvtColor(cv.imread("/root/turboSB_hot.png"),BGR565)[-160:,:120]
sidebar_cool = cv.cvtColor(cv.imread("/root/turboSB.png"),BGR565)[-160:,:120]
def _sidebar_hot():
    logger.warning(f"temp over {int(HIGH_TEMP)}C")
    _change_sidebar(sidebar_hot)
def _change_sidebar(img=sidebar_cool):
    global sidebar_base
    sidebar_base=img.copy()
_change_sidebar()

intemp = CPUTemperature(threshold=HIGH_TEMP,event_delay=1.9)
intemp.when_activated = _sidebar_hot
intemp.when_deactivated = _change_sidebar

# Display frame buffer memory mapped with numpy
frame_buffer = np.memmap("/dev/fb0",dtype='uint8',shape=(SCREEN_HEIGHT,SCREEN_WIDTH,2))
frame_buffer[:160,-SIDEBAR_WIDTH:] = sidebar_base
frame_buffer[:] = np.fromfunction(
    (lambda i,j,k: (np.uint8(j*i*2&(i-199-j)>>8*k))),(480,1600,2),dtype=np.uint8)

def _show_message(text,loc=(500,250),color=COLOR_LAYM,fontScale=3,thickness=4,width=SIDEBAR_WIDTH):
    frame_buffer[:,:-width] = putText(frame_buffer[:,:-width], text, loc, color,
                                      fontScale=fontScale, thickness=thickness)
_show_message("Initializing", (500,250))

# load private bluetooth MAC address for my phone
with open("/root/.btmac","r") as file: mac = file.readline()
def _wifi_state():
    return bash('cat /sys/class/net/wlan0/operstate').stdout == b'up\n'

def data():
    global exit_flag
    global show_graph
    car_connection, touch_input, x = None, None, None
    touch_time = time() + 0.19
    started_names = []

    try: frame_buffer[160:,-SIDEBAR_WIDTH:] = cv.cvtColor(
        cv.imread("/root/newSidebar.png")[1:],BGR565)
    except: logger.warning("couldn't find sidebar!")
    try: # is the wifi connected?
        if _wifi_state(): pass # raise KeyboardInterrupt("wifi connected")
        else: 
            bash('ip link set wlan0 down') # else turn off radio to save power
            Process(target=bash,args=(f"sleep 5; bluetoothctl connect {mac}",),daemon=True).start()
        for func, name in [(get_dash_image,"dash"),
                           (get_image,"read"),
                           (on_screen,"proc"),
                           (save_video,"save")]:
            Process(target=func, name=name, daemon=True).start()
            started_names.append(name)
        _show_message("Initializing...", (500,250))
        logger.info(f'processes started: {started_names}')
        touch_dev_path = "/dev/input/by-id/usb-HQEmbed_Multi-Touch-event-if00"
        Thread(target=display_image, name="show", daemon=True).start()
        while not exit_flag:
            car_connection = ELM327()
            while not exit_flag:
                make_sidebar(car_connection.psi())
                if exit_flag: break
                if time() > touch_time:
                    try:
                        if touch_input is None: touch_input = InputDevice(touch_dev_path)
                        for event in touch_input.read():
                            print("read touch")
                            if event.type == 3:
                                if event.code == 0:
                                    if event.value > FINAL_IMAGE_WIDTH: x = event.value
                                    else: 
                                        print(f"toggle view")
                                        main_pipe1.send("VIEW")
                                else:
                                    if x is not None and event.code == 1:
                                        if event.value > SCREEN_HEIGHT/2:
                                            msg = f'touch input(X ⇁,Y ⇃) -> {x},{event.value}'
                                            logger.info(msg)
                                            raise KeyboardInterrupt()
                                        else: 
                                            show_graph = not show_graph
                                            print(f"graph flag is {show_graph}")
                                            main_pipe1.send("GRAPH")
                                    x = None
                    except BlockingIOError: pass # no new input
                    except (OSError, FileNotFoundError): # janky mcu is ailing
                        if touch_input is not None:
                            touch_input.close()
                            touch_input = None
                        touch_time = time() + 0.38
            if exit_flag: break
    except KeyboardInterrupt: exit_flag = True
    except Exception as ex:
        traceback.print_exc()
        logger.exception(ex)
    finally: leave(car_connection, touch_input)

def leave(car_connection, touch_input):
    global exit_flag
    main_pipe1.close()
    if not exit_flag: exit_flag = True
    if touch_input is not None: touch_input.close()
    if car_connection  is not None: car_connection.close()
    if not _wifi_state(): Popen("shutdown -h now",shell=True) # bash('ip link set wlan0 up')
    bash(f"bluetoothctl disconnect {mac}")

def make_sidebar(psi,queue=sidebar_queue):
    global psi_list
    try:
        entry = max(FDIM[1] - 2 * PPPSI - 15 - int(psi*PPPSI),1)
        psi_list.append(entry)
        sidebar = sidebar_base.copy()
        sidebar = \
                putText(sidebar, f"{psi:.1f}",(4,57), color=COLOR_NORMAL, fontScale=1.19, thickness=3)
        sidebar = putText(sidebar, "BAR" if psi < 0.0 else "PSI", (42,95), color=COLOR_BAD)
        queue.put(sidebar)
    except Exception as e: logger.exception(e)

def display_image(pipe=main_pipe1,queue=sidebar_queue):
    global exit_flag
    global show_graph
    while not exit_flag:
        try:
            try: frame_buffer[:SIDEBAR_HEIGHT,-SIDEBAR_WIDTH:] = queue.get(block=False)
            except Empty: pass
            if pipe.poll(FRAME_DELAY):
                frame_buffer[:,:-SIDEBAR_WIDTH] = pipe.recv()
                if show_graph: build_graph(psi_list.copy(), frame_buffer)
                frame_buffer.flush()
        except EOFError: exit_flag = True
        except Exception as e: logger.exception(e)
        if exit_flag: break

def on_screen(back_pipe=backup_pipe1, dash_pipe=dash_pipe1, main_pipe=main_pipe2):
    back_image, dash_image = None, None
    view_flag, show_graph = False, False
    while True:
        try:
            if main_pipe.poll():
                msg = main_pipe.recv()
                if "VIEW" == msg: 
                    view_flag = not view_flag
                    dash_pipe.send("START" if view_flag else "STOP")
                elif "GRAPH" == msg: show_graph = not show_graph
                else: print(f"bad message from main: {msg}")
            if back_pipe.poll(FRAME_DELAY): back_image = back_pipe.recv()
            else: raise Empty # image = display_queue.get(timeout=0.057)
            if view_flag:
                if dash_pipe.poll(): dash_image = dash_pipe.recv()
                if dash_image is not None: image = output_alt(back_image,dash_image)
            if not view_flag or dash_image is None: image = build_output_image(back_image)
            if show_graph: image = addOverlay(image)
            main_pipe.send(cv.cvtColor(image, BGR565))
        except Empty: pass
        except (EOFError, BrokenPipeError): break
        except Exception: traceback.print_exc()
    for pipe in (back_pipe,dash_pipe,main_pipe): pipe.close()

def get_image(pipe=backup_pipe2):
    width, height = DIM
    read_fail_count = 0
    camera = None
    while True:
        try:
            camera = get_camera(extract_index(),width,height)
            camera.read()
            while camera.isOpened():
                success, image = camera.read()
                if success: pipe.send(image)
                else: read_fail_count += 1
            if pipe.poll(): pipe.recv()
        except (EOFError, BrokenPipeError): break
        except Exception as e: logger.exception(e)
        finally:
            if camera is not None: camera.release()
            print(f'failed reads: {read_fail_count}')
    pipe.close()

def get_dash_image(show_pipe=dash_pipe2,save_pipe=save_pipe1):
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    read_fail_count = 0
    view_flag = False
    while True:
        try:
            camera = get_camera(extract_index(camPath),DASHCAM_IMAGE_WIDTH,DASHCAM_IMAGE_HEIGHT)
            camera.read()
            while camera.isOpened():
                success, image = camera.read()
                if success:
                    if show_pipe.poll():
                        msg = show_pipe.recv()
                        if "START" == msg: view_flag = True
                        elif "STOP" == msg: view_flag = False
                        else: print(f"bad message from main process: {msg}")
                    save_pipe.send(image)
                    if view_flag: show_pipe.send(image)
                else: read_fail_count += 1
        except (EOFError, BrokenPipeError): break
        except AssertionError: print("can't find usb") # reset_usb()
        except Exception as e: logger.exception(e)
        finally:
            if camera is not None: camera.release()
            print(f'failed dash reads: {read_fail_count}')
    show_pipe.close()
    save_pipe.close()


def get_dash_image_old(width=DASHCAM_IMAGE_WIDTH, height=DASHCAM_IMAGE_HEIGHT, video_format="MJPG",
                   show_pipe=dash_pipe2, save_pipe=save_pipe1):
    camPath = "/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_CAMERA_SN0001-video-index0"
    view_flag = False
    while True:
        try:
            with Device.from_id(extract_index(camPath)) as cam:
                video_capture = VideoCapture(cam)
                video_capture.set_format(width,height,video_format)
                with video_capture as stream:
                    for frame in stream: # dashcam_queue.join()
                        if video_format == "MJPG": image = cv.imdecode(frame.array, COLOR)
                        else: image = cv.cvtColor(frame.array.reshape(height, width, 2), YUYV)
                        save_pipe.send(image)
                        if show_pipe.poll():
                            msg = show_pipe.recv()
                            if "START" == msg: view_flag = True
                            elif "STOP" == msg: view_flag = False
                            else: print(f"bad message from main process: {msg}")
                        if view_flag:
                            show_pipe.send(image)
        except EOFError: break 
        except AssertionError: print("can't find usb") # reset_usb()
        except Exception: traceback.print_exc()
    show_pipe.close()
    save_pipe.close()

def save_video(pipe=save_pipe2, camera=None, width=DASHCAM_IMAGE_WIDTH,
               height=DASHCAM_IMAGE_HEIGHT, fps=15): # queue=dashcam_queue,
    fourcc = cv.VideoWriter_fourcc(*'mp4v')
    while True:
        output = None
        try:
            output = cv.VideoWriter(get_video_path(camera), fourcc, fps, (width, height))
            while True:
                if pipe.poll(0.119): 
                    image = pipe.recv() # if speed: pass # (speed,frame_num) -> csv file
                    if image is not None: output.write(image)
                    else: print("empty image!")
                else: print("no dash image to save!")
        except EOFError: break
        except Exception: traceback.print_exc()
        finally:
            if output is not None: output.release()
    pipe.close()

if __name__ == "__main__":
   # set_start_method('spawn') # ,force=True)
    fmtString = '%(asctime)s[%(levelname)-4s]%(threadName)s: %(message)s'
    handler = logging.FileHandler("/root/runtime-carCam.log")
    level = logging.DEBUG
    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmtString))
    logger = logging.getLogger()
    logger.setLevel(level)
    logger.addHandler(handler) # turn off red LED \/  \/
    bash('echo none > /sys/class/leds/PWR/trigger; echo 0 > /sys/class/leds/PWR/brightness')
    data()
